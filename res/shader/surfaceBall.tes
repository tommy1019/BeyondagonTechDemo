#version 410

layout(quads) in;

in vec3 tcPosition[];

out vec3 tePosition;
out vec3 tePatchDistance;
out vec3 normal;
out vec2 textureCoord;

uniform int numPatches;

uniform mat4 transform;
uniform mat4 projection;

vec3 getPointOnCurve(vec3 a0, vec3 a1, vec3 a2, vec3 a3, float t)
{
    float b0 = (1 - t) * (1 - t) * (1 - t);
    float b1 = 3 * t * (1 - t) * (1 - t);
    float b2 = 3 * t * t * (1 - t);
    float b3 = t * t * t;

    return a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
}

vec3 getPointOnDCurve(vec3 a0, vec3 a1, vec3 a2, vec3 a3, float t)
{
    float db0 = -3 * (1 - t) * (1 - t);
    float db1 = 9 * t * t - 12 * t + 3;
    float db2 = 6 * t - 9 * t * t;
    float db3 = 3 * t * t;

    return a0 * db0 + a1 * db1 + a2 * db2 + a3 * db3;
}

void main()
{
    vec3 p[4];

    for(int i = 0; i < 16; i += 4)
    {
        p[i / 4] = getPointOnCurve(tcPosition[i], tcPosition[i + 1], tcPosition[i + 2], tcPosition[i + 3], gl_TessCoord.x);
    }

    vec3 tmp[4];

    vec3 dv[4];
    for (int i = 0; i < 4; ++i)
    {
        tmp[0] = tcPosition[i];
        tmp[1] = tcPosition[i + 4];
        tmp[2] = tcPosition[i + 8];
        tmp[3] = tcPosition[i + 12];

        dv[i] = getPointOnCurve(tmp[0], tmp[1], tmp[2], tmp[3], gl_TessCoord.x);
    }

    vec3 dvTan = getPointOnDCurve(dv[0], dv[1], dv[2], dv[3], gl_TessCoord.x);
    vec3 duTan = getPointOnDCurve(p[0], p[1], p[2], p[3], gl_TessCoord.y);

    tePosition = vec3(getPointOnCurve(p[0], p[1], p[2], p[3], gl_TessCoord.y));
    gl_Position = vec4(tePosition, 1) * projection;
    textureCoord = vec2(gl_TessCoord.x, (gl_TessCoord.y + gl_PrimitiveID) / numPatches); 
    normal = (vec4(normalize(cross(duTan, dvTan)), 1) * transform).xyz;
}
